# 빗물

https://www.acmicpc.net/problem/14719

## 문제

![빗물](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14719/2.png)

- 세로 길이 `H`, 가로 길이 `W`가 주어진다.
- 고이는 빗물의 양은?

## 아이디어

- 투 포인터를 사용한다. a, b 포인터가 있는데
- `height[a]` > `height[a + 1]`인 포인터 a를 구한다.
- `height[a]` >= `height[b]`를 구한다.
- 빗물 용량을 구하고 a 포인터에 b를 새롭게 할당한다.
- 범위가 유효할 때까지 반복.

## 해결

- 위 방법으로 하면 처리할 수 없는 엣지 케이스가 있다.
- `height[a]`가 남은 범위에서 가장 커서 남은 `height[b]`가 모조리 `height[a]`보다 작은 경우이다. 이렇게 되면 `b`는 적절한 벽을 찾지 못하고 `W`까지 간다.
- 이 경우 `height[a+1:]` 중 가장 큰 블록이 `height[b]`가 되도록 해야한다.

```python
# 엣지 케이스 처리
if a + 1 < W and b == W:
    b = height.index(max(height[a + 1:]), a + 1)
```

- 또한 시간을 줄이고 싶어서 포인터를 사용하여 계산 전, `W`가 3 이상이고, 맨 왼쪽 벽과 맨 오른쪽 벽이 가장 높은 벽이면 바로 빗물의 양을 구할 수 있는 경우를 처리했다.

```python
if W >= 3 and height[0] == height[-1] == max(height):
    print(sum(map(lambda x: height[0]-x, height)))
    exit(0)
```

## 다른 방법

```python
H, W = map(int, input().split())
height = list(map(int, input().split()))

answer = 0
for i in range(1, W - 1):
    left_max = max(height[:i])
    right_max = max(height[i+1:])

    h = min(left_max, right_max)

    if height[i] < h:
        answer += h - height[i]

print(answer)
```

0과 W-1번 블록에서는 빗물이 고일 수 없으므로, 빗물이 고일 수 있는 블록(1, 2, ..., W-2)을 하나씩 검사한다.
현재 블록의 왼쪽 블록들에서 가장 높은 블록과, 오른쪽 블록들에서 가장 높은 블록을 구한다. 이들 중 하나라도 현재 블록보다 높으면 이 블록은 `해당 블록의 높이 - 현재 블록의 높이`만큼 빗물이 고일 수 있다.
