# 종이_조각

https://www.acmicpc.net/problem/14391

## 문제

- `N` * `M` 크기의 종이 조각이 있다.
- 가로 직사각형 혹은 세로 직사각형으로 자를 수 있다.
- 직사각형에 적힌 숫자들 읽는다고 할 때(가로 직사각형은 왼쪽->오른쪽으로, 세로 직사각형은 위->아래로 읽음)
- 이 숫자들의 합이 최대가 되는 경우 이 값은?

## 아이디어

- 직사각형에서 각 칸은 세로 직사각형이나 가로 직사각형에 포함될 수 있다.
- 즉, 각 직사각형이 세로 직사각형에 속하거나 가로 직사각형에 포함되는 모든 경우의 수는 `2^(N*M)`이다.
- 모든 경우의 수에 대해 각각 숫자들의 합을 구하고 최대를 구한다.

## 해결

- 처음에는 칸 수가 제일 많고 맨 앞자리 수가 제일 큰 순대로 조각을 자르는 그리디라고 생각했는데, 다음과 같은 반레가 있다.
```python
9 9
1 1
```

이 경우 99를 먼저 뽑고 그 다음 11을 뽑아 합은 110이 되는데, 91과 91을 뽑으면 182로 이 경우가 최댓값이다.

- 따라서 모든 경우의 수를 살피는 것이 적절하다.
- 가로 직사각형에 속하는 칸을 1로, 세로 직사각형에 속하는 칸을 0으로 표시한다고 하자. 이렇게 모든 경우의 수를 구하는 것은 조합이다.
- 왜냐하면 N*M개의 칸이 있다면 이중에서 일부만 선택(세로에 속하는 칸만 뽑으면 나머지는 자동으로 가로에 속하는 칸이 됨)하는 것과 같기 때문이다.
- 조합은 백트래킹으로 구하거나, 비트마스킹으로 구할 수 있다.
- 나는 백트래킹을 써보았다. 종이 조각이 2차원이지만 간단하게 하기 위해 2차원 인덱스를 1차원처럼 표현했다.

```python
def backtracking(cur):
	global result
	if cur == (N * M):
		result = max(result, 합구하기())
		return

	visited[cur] = 1
	backtracking(cur + 1)
	visited[cur] = 0
	backtracking(cur + 1)
```